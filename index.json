[
{
	"uri": "https://ihrivnac.github.io/installation/examples/build-options/",
	"title": "Build Options",
	"tags": [],
	"description": "",
	"content": "Overview of the available options for building VMC examples and their default values:\nVMC_WITH_Geant4 Build with Geant4 OFF VMC_WITH_Geant3 Build with Geant3 OFF VMC_WITH_Multi Build with multiple engines OFF VMC_INSTALL_EXAMPLES Install examples libraries and programs ON Geant4 VMC build options are automatically exported in Geant4VMCConfig.cmake. If Geant4 VMC was built with VGM, the VGM installation path has to be provided via -DVGM_DIR option.\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/geant4_vmc/build-options/",
	"title": "Build Options",
	"tags": [],
	"description": "",
	"content": "Geant4 VMC includes the G4Root package and examples, which are independent from Geant4 VMC and can be build and used stand-alone. Use of G4Root, VGM, Geant4 G3toG4, UI and VIS packages in Geant4 VMC library is optional and can be switched on/off during CMake build.\nOverview of available options and their default values:\nGeant4VMC_BUILD_G4Root Build G4Root ON Geant4VMC_BUILD_MTRoot Build MTRoot ON Geant4VMC_BUILD_Geant4VMC Build Geant4VMC ON Geant4VMC_BUILD_EXAMPLES Build VMC examples ON Geant4VMC_USE_G4Root Build with G4Root ON Geant4VMC_USE_VGM Build with VGM OFF Geant4VMC_USE_GEANT4_UI Build with Geant4 UI drivers ON Geant4VMC_USE_GEANT4_VIS Build with Geant4 Vis drivers ON Geant4VMC_USE_GEANT4_G3TOG4 Build with Geant4 G3toG4 library OFF Geant4VMC_INSTALL_EXAMPLES Install examples ON "
},
{
	"uri": "https://ihrivnac.github.io/installation/examples/examples-old/",
	"title": "Building examples application programs - With 3.00.b01",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://ihrivnac.github.io/download/",
	"title": "Download",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Download The VMC packages sources are available from the vmc-project organization in GitHub. See the detailed instructions in the next sections.\nVMC Geant3 Geant4 VMC Tar Files "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/geometry-definition-navigation/",
	"title": "Geometry Definition &amp; Navigation",
	"tags": [],
	"description": "",
	"content": "Geometry definition The VMC supports two ways of geometry definition:\nvia Root geometry package (TGeo) via TVirtualMC interface (historically the first way) The first (newer) way is recommended for new users, the way via VMC is kept for a backward compatibility.\nSince the version 2.0, user can choose between Geant4 native navigation and G4Root navigation, if geometry is define via TGeo. The choice of the navigation is done via the option specified with creating TG4RunConfiguration object (see VMC examples for more details):\ngeomVMCtoGeant4 - geometry defined via VMC, G4 native navigation geomVMCtoRoot - geometry defined via VMC, Root navigation geomRoot - geometry defined via Root, Root navigation geomRootToGeant4 - geometry defined via Root, G4 native navigation geomGeant4 - geometry defined via Geant4, G4 native navigation Below we shortly comment the implementation of these options:\ngeomVMCtoGeant4: The interfaces to functions for geometry definitions provided by VMC were strongly inspired by Geant3; the implementation of these functions in Geant4 VMC is therefore made with use of the G3toG4 tool provided by Geant4.\ngeomVMCtoRoot: The implementation of this option uses TGeoMCGeometry provided in the root/vmc package. The same class is used also by TGeant3TGeo and TFluka for supporting user geometry defined via VMC.\ngeomRoot: If geometry is defined via Root and G4Root navigation is selected, Geant4 VMC only converts the parameters defined in TGeoMedium objects to Geant4 objects.\ngeomRootToGeant4: The geometry defined via TGeo is converted in Geant4 geometry using the external Virtual Geometry Model (VGM), which has replaced the old one-way converters from Geant4 VMC (G4toXML, RootToG4), removed from Geant4 VMC with the version 1.7. In the VGM, these convertors has been generalized and improved.\ngeomGeant4: User Geant4 detector construction class can be passed to Geant4 VMC via user defined run configuration class (see User Geant4 Classes). If Geant4 VMC is built with VGM, geometry can be exported in Root using the built-in command:\n/vgm/generateRoot and reused in Geant3 or Fluka (when available) VMC simulation.\nUseful commands Geant4 VMC implements various commands which allow users to get more information about their application setup:\n/mcDet/printMaterials /mcDet/printMaterialsProperties /mcDet/printMedia /mcDet/printVolumes prints materials, material properties, tracking media, volumes\nIn Geant4 VMC, there is by default set a step limit 10 cm for all materials with density lower than 0.001 g/cm3. This default setting can be overridden via the following commands:\n/mcDet/setLimitDensity 1.e-6 g/cm3 /mcDet/setMaxStepInLowDensityMaterials 1 mm How to apply Geant4 commands in a Root user session is explained at the section on Switching User Interfaces.\nGeometry in XML The VGM provides also the XML exporters which enable to generate XML files with geometry description in the AGDD or GDML formats. If Geant4 VMC is compiled with USE_VGM option, geometry can be exported to XML using the built-in commands:\n/vgm/generateAGDD [volumeName] /vgm/generateGDML [volumeName] If volumeName is not specified, the whole geometry volume tree is exported. The geometry can be then browsed and visualized using GraXML tool.\n\u0026ldquo;MANY\u0026rdquo; positions As Geant4 does not support overlapping geometries, the positions with MANY option are not allowed with Geant4 navigation.\nIn case of geomVMCtoGeant4 option, user has a possibility to identify all ONLY volumes that overlap with the MANY ones using TVirtualMC::Gsbool() function for each overlap. This info is then used to perform automatically Boolean operations on the concerned solids. The volume with a \u0026ldquo;MANY\u0026rdquo; position can have only this position if Gsbool is used.\nIn case of geomRootToGeant4 option, the MANY option is ignored and if present in geometry, Gean4 geometry will be incorrect.\nThere is no limitation on use of the MANY option with G4Root navigation (options geomVMCtoRoot, geomRoot).\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/geant3/geant3-old/",
	"title": "Installing Geant3 - Older Versions",
	"tags": [],
	"description": "",
	"content": "The following instructions apply to the installation of the versions \u0026lt; 2.0.\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/geant4_vmc/geant4_vmc-old/",
	"title": "Installing Geant4 VMC - Older Versions",
	"tags": [],
	"description": "",
	"content": " \u0026lt;li\u0026gt;\u0026lt;b\u0026gt;OpenGL visualization \u0026lt;/b\u0026gt; \u0026lt;br\u0026gt; It is recommended to build Geant4 X11 OpenGL visualization driver used in the VMC examples. It is handled in Geant4 CMake build via the following CMake option:\n-DGEANT4_USE_OPENGL_X11=ON \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; Geant4 VMC \u0026lt;/h3\u0026gt; "
},
{
	"uri": "https://ihrivnac.github.io/installation/vmc/",
	"title": "Installing VMC",
	"tags": [],
	"description": "",
	"content": "VMC requires ROOT.\nThe vmc core package was separated from the ROOT source into a new stand-alone vmc package in the GitHub vmc-project organization. The motivation for this step was a gain in flexibility and faster workflow for new developments of multiple engine mode. The vmc package in ROOT is deprecated since ROOT version 6.18 (its compilation is optional) and it is going to be removed in the next ROOT version, 6.26. The VMC stand-alone is then needed for building Geant3 and Geant4 VMC when using ROOT compiled with the vmc disabled (default).\nVMC uses CMake to configure a build system for compiling and installing the headers, libraries and Cmake configuration files. To install VMC:\nFirst get the VMC source from the Download page. We will assume that the VMC package sits in a subdirectory /mypath/vmc Create build directory alongside our source directory $ cd /mypath $ mkdir vmc_build $ ls vmc vmc_build To configure the build, change into the build directory and run CMake: $ cd /mypath/vmc_build $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/vmc_install /mypath/vmc If ROOT environment was defined using thisroot.{c}sh script, there is no need to provide the path to its installation. Otherwise, they can be provided using -DROOT_DIR cmake option.\nThe VMC core is built by default in RelWithDebInfo build mode (Optimized build with debugging symbols). This default can be changed via the standard CMake option CMAKE_BUILD_TYPE. The other useful values are Release : Optimized build, no debugging symbols Debug : Debugging symbols, no optimization After the configuration has run, CMake will have generated Unix Makefiles for building VMC. To run the build, simply execute make in the build directory: $ make -jN where N is the number of parallel jobs you require (e.g. if your machine has a dual core processor, you could set N to 2).\nIf you need more output to help resolve issues or simply for information, run make as $ make -jN VERBOSE=1 Once the build has completed, you can install VMC to the directory you specified earlier in CMAKE_INSTALL_PREFIX by running $ make install "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 3.1 Introduction This chapter presents the VMC concept, and gives an overview of the packages provided in vmc-project.\nVMC Concept VMC Project "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/magnetic-field/",
	"title": "Magnetic Field",
	"tags": [],
	"description": "",
	"content": "The user magnetic field is in VMC defined via TVirtualMagField interface and then set to VMC using TVirtualMC::SetMagField(TVirtualMagField*) function. The propagation of tracks inside the magnetic field in Geant4 can be performed to a user-defined accuracy. See more details in the Electromagnetic Field section in the Geant4 User Guide for Application Developers. Note that while Geant4 allows magnetic, electric and electromagnetic fields, the VMC is currently limited to magnetic fields only.\nLocal fields Since Geant4 VMC version 3.2, it is possible to define local magnetic fields. The local field is defined in the same way as a global field, via TVirtualMagField interface, but then it has to be associated with a selected volume using TGeoVolume::SetField(TObject*) function. The local magnetic field is applied also to all volume daughters, it is possible to combine a global field with one or more local fields. Note that the local fields are supported only with Geant4 and an equivalent global magnetic field has to be provided for Geant3 simulation.\nThe local fields defined in Root geometry are not taken into account automatically (to avoid unnecessary processing of the volume tree in applications which do not define local magnetic fields) and their usage has to be activated via:\n/mcDet/setIsLocalMagField true Since Geant4 VMC version 3.5, it is possible to propagate the zero magnetic field defined in tracking media in Geant4 geometry. A local zero magnetic field is set to all logical volumes associated with the tracking medium with \u0026lsquo;ifield = 0\u0026rsquo; if a global magnetic field is defined. This feature (not switched on by default) can be activated via:\n/mcDet/setIsZeroMagField true Customization of Field Parameters In Geant4 VMC, user can customize the default integration method and the default accuracy parameters with a set of dedicated commands. It is a user responsibility to choose the type of equation of motion and the integration method compatible with the user field. (The defined commands are not limited to magnetic field only in order to make easier an eventual future extension of VMC to electric and electromagnetic fields.)\nThe available commands:\nSelect the integrator (stepper) of particle\u0026rsquo;s equation of motion; the default stepper is G4ClassicalRK4:\n/mcMagField/stepperType stepperType Select the type of equation of motion of a particle in a field; the default is G4Mag_UsualEqRhs:\n/mcMagField/equationType eqType Set the accuracy parameters delta intersection and delta one step of the G4 Field Manager. The default values in Geant4 are 0.001mm and 0.01mm respectively.\n/mcMagField/setDeltaIntersection value [unit] /mcMagField/setDeltaOneStep value [unit] Set the step minimum and delta chord parameters to G4 Chord Finder. The default values in Geant4 are 0.01mm and 0.25mm respectively.:\n/mcMagField/setStepMinimum value [unit] /mcMagField/setDeltaChord value [unit] Set the MinimumEpsilonStep and the MaximumEpsilonStep parameters of the G4 Field Manager. The default values in Geant4 are 5.0e-5 and 0.001 respectively.\n/mcMagField/setMinimumEpsilonStep value /mcMagField/setMaximumEpsilonStep value Activate utilizing of a \u0026ldquo;cached magnetic field\u0026rdquo; (available since version 3.2) . The cached field value (the value from a previous call) is returned in case a new call is performed for a point which distance from a previous one is smaller than the value of the \u0026ldquo;ConstDistance\u0026rdquo; parameter.\n/mcMagField/setConstDistance value [unit] To customize local field parameters, a command directory for the local field has to be created first using:\n/mcDet/createMagFieldParameters volumeName The same commands as for a global field are then available under this directory:\n/mcMagField/volumeName/stepperType stepperType /mcMagField/volumeName/equationType eqType ... Since Geant4 VMC version 3.2, users can also provide their own magnetic field equation of motion and/or its integrator. These objects should be instantiated in a detector construction class derived from TG4DetConstruction or post-detector construction class derived from TG4VUserPostDetConstruction if using ROOT navigation. This use case is demonstrated in the E03 example in Ex03PostDetConstruction and Ex03RunConfiguration4 classes. How to include user Geant4 classes in a VMC application is explained at the section on User Geant4 classes.\nControl of the parameters for killing looping particles Since Geant4 10.5, users can change the thresholds for killing ‘looping’ tracks, which criteria can be used to ensure that a track continues to propagate and for how many steps an ‘important’ track that is ‘looping’ can survive (see more details in Transportation in Magnetic Field - Further Details section in Geant4 Guide for Application Developers).\nThe following UI commands were introduced in Geant4 VMC development version, and back-ported to Geant4 VMC 5.0.p5, for this control.\nThe commands for using preset thresholds for killing loopers:\n/mcPhysics/useLowLooperThresholds /mcPhysics/useHighLooperThresholds The commands for modifying the parameters for killing looping particles\n/mcRun/setLooperThresholdWarningEnergy value unit /mcRun/setLooperThresholImportantEnergy value unit /mcRun/setNumberOfLooperThresholdTrials value These commands must be called before the run initialization, so that Geant4 VMC performs the setting at the right time.\nHow to apply Geant4 commands in a Root user session is explained at the section on Switching User Interfaces.\n"
},
{
	"uri": "https://ihrivnac.github.io/support/mailing-list/",
	"title": "Mailing List",
	"tags": [],
	"description": "",
	"content": "The mailing list is used to keep you up to date about new developments in VMC packages, releases and bug fixes. This list is also used to discuss use of VMC with other users and with the developers. If you want to report a bug, please, use Bug Reports.\nTo join the root-vmc@cern.ch mailing list, do the following:\nIf you don\u0026rsquo;t have a CERN account, create a light weight CERN account. Add yourself to the root-vmc mailing list, by clicking on the \u0026ldquo;Members\u0026rdquo; tab and then on the \u0026ldquo;Add me\u0026rdquo; button. To remove yourself from the mailing list click on the \u0026ldquo;Remove me\u0026rdquo; button on the same above \u0026ldquo;Members\u0026rdquo; page. Mailing list archive: VMC Digest\n"
},
{
	"uri": "https://ihrivnac.github.io/publications/publications-list/",
	"title": "Publications List",
	"tags": [],
	"description": "",
	"content": "Please refer to the paper below when publishing results base on simulations with VMC:\nReference paper\nHřivnáčová I et al: The Virtual MonteCarlo,\nECONF C0303241:THJT006,2003; e-Print: cs.SE/0306005\nAll publications listed in time reversed order:\nNew Developments in the VMC Project,\nI Hřivnáčová, B Volkel 2020 EPJ Web Conf. Volume 245 02005\ndoi: 10.1051/epjconf/202024502005\nUsing multiple engines in the Virtual Monte Carlo package,\nB Volkel et al 2020 EPJ Web Conf. Volume 245 02008\ndoi: 10.1051/epjconf/202024502008\nGeant4 VMC 3.0,\nI Hřivnáčová, A Gheata 2015 J. Phys.: Conf. Ser. 664 072020\ndoi: 10.1088 /1742-6596/664/7/072020\nThe Geant4 Virtual Monte Carlo,\nI Hřivnáčová 2012 J. Phys.: Conf. Ser. 396 022024\ndoi:10.1088 /1742-6596/119/3/032025\nPhysics lists in Geant4 VMC,\npresentation at ALICE-FAIR Computing Meeting, 28-29 April 2008, GSI\nThe Geant4 Virtual Monte Carlo,\nI Hřivnáčová 2008 J. Phys.: Conf. Ser. 119 032025\ndoi: 10.1088 /1742-6596/119/3/032025\nFLUKA and the Virtual Monte Carlo,\nA. Morsch - presentation at CHEP 2006, 13-17th February 2006, Mumbai, India\nThe Virtual MonteCarlo: status and applications,\nR. Brun et al - presentation at CHEP 2004, 27 September 2004 to 01 October 2004, Interlaken, Switzerland\nThe Virtual MonteCarlo,\nHřivnáčová I et al 2003 Proc. of Computing in High Energy and Nuclear Physics (La Jolla) pp THJT006\nECONF C0303241:THJT006,2003; e-Print: cs.SE/0306005\n(Reference paper)\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/examples/running-examples/",
	"title": "Running examples",
	"tags": [],
	"description": "",
	"content": "First, make sure that you have included all libraries paths in your shared library path.\nFor all MCs:\n/your_path/root_install/lib /your_path/vmc_install/lib For Geant3 only:\npath to Pythia6 library /your_path/geant3_install/lib[64] /your_path/examples_install_g3/lib[64] For Geant4 only:\n/your_path/geant4_install/lib[64] /your_path/geant4_vmc_install/lib[64] /your_path/examples_install_g4/lib[64] Running examples from Root session The example can be run by calling the provided macros from Root session:\n$ cd geant4_vmc/examples/E01 $ root root[0] .x load_g4.C # load all libraries needed to run with Geant4 root[1] .x run_g4.C # run with Geant4 or root[0] .x load_g3.C # load all libraries needed to run with Geant3 root[1] .x run_g3.C # run with Geant3 Running examples application programs The example can be also run by calling the executable from the examples installation directory:\n$ cd geant4_vmc/examples/E01 $ /mypath/examples_install_g4/bin/g4vmc_exampleE01 For keeping maximum simplicity of the code, a fixed configuration is defined in the examples main() function. More flexible version of the main() function is provided in the test programs which default configuration options can be changed by running the program with selected command line options, eg.\n$ g4vmc_testE01 [-g4g, --g4-geometry] Geant4 VMC geometry option [-g4pl, --g4-physics-list] Geant4 physics list selection [-g4sp, --g4-special-physics] Geant4 special physics selection [-g4m, --g4-macro] Geant4 macro [-g4vm, --g4-vis-macro] Geant4 visualization macro [-r4m, --root-macro] Root macro [-v, --verbose] verbose option (yes,no) or\n$ g3vmc_testE01 [-g3g, --g3-geometry] Geant3 geometry option [-r4m, --root-macro] Root macro [-v, --verbose] verbose option (yes,no) Note that the g4* and g3* options are available only when the program was built with the corresponding VMC_WITH_Geant4 or VMC_WITH_Geant3 option. Root macro with arguments has to be passed in a single string, eg.:\n--root-macro \u0026#39;test_E01.C(\u0026#34;\u0026#34;,kFALSE)\u0026#39; "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/introduction/vmc-concept/",
	"title": "VMC Concept",
	"tags": [],
	"description": "",
	"content": "The Virtual Monte Carlo (VMC) allows to run different simulation Monte Carlo without changing the user code and therefore the input and output format as well as the geometry and detector response definition.\nThe core of the VMC is the category of classes vmc. It provides a set of interfaces which completely decouple the dependencies between the user code and the concrete Monte Carlo, two of which have the key role:\nTVirtualMC: Interface to the concrete Monte Carlo program TVirtualMCApplication: Interface to the user\u0026rsquo;s Monte Carlo application The implementation of the TVirtualMC interface is provided for two Monte Carlo transport codes, GEANT3 and Geant4, with the VMC packages listed below. The implementation for the third Monte Carlo transport code, FLUKA, has been discontinued by the FLUKA team in 2010.\nThe other interfaces are implemented in the user application. The user VMC application is independent from concrete transport codes (GEANT3, Geant4, FLUKA). The transport code which will be used for simulation is selected at run time - when processing a ROOT macro where the concrete Monte Carlo is instantiated.\nVMC and TGeo The VMC is fully integrated with the Root geometry package, TGeo, and users can easily define their VMC application with TGeo geometry and this way of geometry definition is recommended for new users.\nIt is also possible to define geometry via Geant3-like functions defined in the VMC interface, however this way is kept only for backward compatibility and should not be used by new VMC users.\nMultiple VMCs Since the development version the simulation can be shared among multiple different engines deriving from TVirtualMC which are handled by a singleton TMCManager object.\nSee more detailed description in the dedicated section.\n"
},
{
	"uri": "https://ihrivnac.github.io/examples/vmc-examples/",
	"title": "VMC Examples",
	"tags": [],
	"description": "",
	"content": "A set of examples of usage of VMC is included in geant4_vmc.\nThough provided within Geant4 VMC, they can be built independently and do not require Geant4 installation in case you want to run them with GEANT3 only.\nSee more details on the VMC Examples web page.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/introduction/vmc-project/",
	"title": "VMC Project",
	"tags": [],
	"description": "",
	"content": "The vmc-project GitGub organization provides the following packages:\nvmc -\u0026gt; The core of the VMC provides the interfaces and classes independent from the Monte Carlo transport code.\nSee more in the VMC Core section.\ngeant3 -\u0026gt; The updated version of Geant3.21 that includes several bug fixes compared to the standard version in CERNLIB. The directory TGeant3 contains the classes which implement the TVirtualMC interface for Geant3\nSee more in the Geant3 section.\ngeant4_vmc -\u0026gt; Geant4 VMC contains the classes which implement the TVirtualMC interface for Geant4.\nFor historical reasons, it also includes the G4Root package, which is independent from Geant4 VMC and can be built and used stand-alone, and VMC Examples, that can also be built independently and do not require Geant4 installation in case you want to run them with GEANT3.\nSee more in the Geant4 VMC, G4Root and Examples sections.\nOther packages In addition to these VMC packages, the vmc-project includes also the geometry conversion tool VGM and the VMC and VGM documentation repositories.\n"
},
{
	"uri": "https://ihrivnac.github.io/support/bug-reports/",
	"title": "Bug Reports",
	"tags": [],
	"description": "",
	"content": "We use JIRA to track bugs and to gather feature requests.\nReport a bug in VMC packages.\n"
},
{
	"uri": "https://ihrivnac.github.io/examples/experiment-frameworks/",
	"title": "Experiment Frameworks",
	"tags": [],
	"description": "",
	"content": "VMC was developed by the ALICE Software Project and, since then it was adopted by other experiment frameworks.\nALICE AliRoot - the ALICE software framework (for LHC Run 1 and 2) O2 - the new ALICE software framework in development (for LHC Run 3 and 4) FAIR FairRoot - A simulation, reconstruction and analysis framework, based on the ROOT system, for FAIR experiments "
},
{
	"uri": "https://ihrivnac.github.io/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Installation Installing VMC Installing Geant3 Installing Geant4 VMC Build Options Required and Optional Packages Installing and Running Examples Build Options Running examples "
},
{
	"uri": "https://ihrivnac.github.io/installation/geant3/",
	"title": "Installing Geant3",
	"tags": [],
	"description": "",
	"content": "Geant3 with VMC requires the VMC core package and ROOT.\nThe vmc core package was separated from the ROOT source into a new stand-alone vmc package in the GitHub vmc-project organization. The motivation for this step was a gain in flexibility and faster workflow for new developments of multiple engine mode. The vmc package in ROOT is deprecated since ROOT version 6.18 (its compilation is optional) and it is going to be removed in the next ROOT version, 6.26. The VMC stand-alone is supported since Geant3 3.0.\nGeant3 with VMC uses CMake to configure a build system for compiling and installing the headers, libraries and Cmake configuration files.\nTo install geant3:\nFirst get the Geant3 source from the Download page. We will assume that the Geant3 package sits in a subdirectory /mypath/geant3 Create build directory alongside our source directory $ cd /mypath $ mkdir geant3_build $ ls geant3 geant3_build To configure the build, change into the build directory and run CMake: $ cd /mypath/geant3_build $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/geant3_install /mypath/geant3 If ROOT environment was defined using thisroot.{c}sh script, there is no need to provide the path to its installation. Otherwise, they can be provided using -DROOT_DIR cmake option.\nSince Geant3 3.9, the VMC stand-alone library has to be provided using -DVMC_DIR cmake option. If the VMC stand-alone library is not found, the deprecated VMC library in ROOT (availble if ROOT was built with the vmc option enabled) can still be used, a deprecation warning will be issued in this case.\nSince Geant3 4.0, the deprecated VMC library in ROOT cannot be used and building against ROOT built with the vmc option enabled will fail with CMake error.\nThe Geant3 library is built by default in RelWithDebInfo build mode (Optimized build with debugging symbols). This default can be changed via the standard CMake option CMAKE_BUILD_TYPE. The other useful values are Release : Optimized build, no debugging symbols Debug : Debugging symbols, no optimization After the configuration has run, CMake will have generated Unix Makefiles for building Geant3. To run the build, simply execute make in the build directory: $ make -jN where N is the number of parallel jobs you require (e.g. if your machine has a dual core processor, you could set N to 2).\nIf you need more output to help resolve issues or simply for information, run make as $ make -jN VERBOSE=1 Once the build has completed, you can install Geant3 to the directory you specified earlier in CMAKE_INSTALL_PREFIX by running $ make install The instructions above apply to the installation since the version 2.0. For the installation of the previous versions (1.x) see Installing geant3 - Older Versions\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/geant4_vmc/special-installations/",
	"title": "Installing Geant4 VMC - Special Installations",
	"tags": [],
	"description": "",
	"content": " \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt;Geant4 configuration (version \u0026gt;= 9.5) \u0026lt;br\u0026gt; with manual installation (with GNUmake) \u0026lt;/h3\u0026gt; If you install Geant4 with the GNUmakefile build system and your own environment setting, you need to have set the following environment variables. This way of installation requires an experience in Geant4 and so it is not recommended for novice users.\nG4LIB_BUILD_SHARED set to 1 (required) G4LIB_USE_G3TOG4 set to 1 (required) G4VIS_BUILD_OPENGLX_DRIVER set to 1 (recommended) G4VIS_USE_OPENGLX set to 1 (recommended) If Geant4 is installed in a different path than the path to the source tree, the following additional variables have to be set: G4LIB \u0026hellip; path to Geant4 libraries (optional) G4INCLUDE \u0026hellip; path to Geant4 include files (option) "
},
{
	"uri": "https://ihrivnac.github.io/installation/geant4_vmc/required-optional-packages/",
	"title": "Required and Optional Packages",
	"tags": [],
	"description": "",
	"content": "Geant4 VMC requires ROOT and Geant4 installed, then the VMC core package if using ROOT built without vmc enabled, and optionally, it can be built with VGM. See below tips for configuration and installation of these packages.\nThe path to required and optional packages installations can be defined in the standard CMake way, via the paths to the CMake configuration file:\nGeant4_DIR ... path to Geant4Config.cmake ROOT_DIR ... path to ROOTConfig.cmake VMC_DIR ... path to VMCConfig.cmake VGM_DIR ... path to VGMConfig.cmake CMake will also find the CMake configuration files (for ROOT and Geant4) if you source the relevant script from the packages installations (CMAKE_INSTALL_PREFIX) so that they are available in the sestem paths:\n$ . bin/geant4.sh ... Geant4 - on bourne shells (eg. bash) $ . bin/thisroot.sh ... Root or $ source bin/geant4.csh ... Geant4 - on C shells $ source bin/thisroot.csh ... Root C++11 Geant4 VMC, as well as ROOT and Geant4, have moved to the C++11 standard. C++11 is used by default since Geant4 VMC 3.3, Geant4 10.2 and ROOT 6.\nWhen mixing other versions of Geant4 and ROOT together, the same standard must be used for both packages. See below how the override the default setting when needed.\nROOT To install ROOT - follow the Root Installation Page\nC++11 Geant4 VMC 3.3 built against ROOT 5.x requires ROOT built with C++11 (not default for this ROOT version), set via: -Dcxx11=ON option, when ROOT is built using CMake, or\n--enable-cxx11 option, when ROOT is built using configure script.\nGeant4 To install Geant4 - download the source from Geant4 Download page and follow the Geant4 Installation Guide together with the tips relevant to using it with VMC described below.\nC++11 Geant4 VMC 3.0 - 3.2 built against Geant4 10.0.x or 10.1.x and ROOT 6x requires Geant4 built with C++11 (not default for these Geant4 versions), set via: -DGEANT4_BUILD_CXXSTD=c++11 G3toG4 tool The G3toG4 package is used in geant4_vmc to support geometry definition via VMC with Geant4 native navigation. The build of G3toG4 package can be activated when building Geant4 with the following CMake options: -DGEANT4_USE_G3TOG4=ON Since Geant4 VMC 3.0 the use of this package is optional.\nOpenGL visualization It is recommended to build Geant4 X11 OpenGL visualization driver used in the VMC examples. It is handled in Geant4 CMake build via the CMake option: -DGEANT4_USE_OPENGL_X11=ON Multi-threading Geant4 VMC can be built against Geant4 installation in multi-threading mode which is handled in Geant4 CMake build via the CMake option: -DG4MULTITHREADED=ON Dynamic loading of Geant4 libraries, as used in VMC, requires to change the Geant4 default TLS model, initial-exec, with global-dynamic via the CMake option:\n-DGEANT4_BUILD_TLS_MODEL=global-dynamic Geant4 VMC 3.00.x version is migrated to Geant4 multi-threading and can be built against both Geant4 sequential and Geant4 multi-threading installations. The global-dynamic model is required for running VMC applications from Root session (in a \u0026ldquo;traditional\u0026rdquo; way with dynamic loading of libraries). When the VMC application main program is linked with all libraries, Geant4 built with the default TLS model can be used.\nThe VMC application will run automatically in MT mode when Geant4 VMC is built against Geant4 MT. See the page on Multi-threaded processing how this default behaviour can be changed in the configuration of the application.\nVGM (optional) VGM is used in Geant4 VMC for a geometry in memory conversion from Root TGeo objects to the Geant4 native geometry. This conversion is performed when users geometry is defined via the Root geometry package and Geant4 native geometry navigation is selected.\nTo install VGM - follow the installation instructions on the VGM Web site.\nTo build Geant4 VMC with VGM, you have to select the option:\n-DGeant4VMC_USE_VGM=ON "
},
{
	"uri": "https://ihrivnac.github.io/download/git-vmc/",
	"title": "VMC",
	"tags": [],
	"description": "",
	"content": "Development version (the whole repository):\ngit clone http://github.com/vmc-project/vmc.git To switch to \u0026lsquo;pro\u0026rsquo; tagged version 2.0:\ncd vmc git checkout v2-0 To switch to the \u0026lsquo;old\u0026rsquo; tagged version 1.1.p1:\ncd vmc git checkout v1-1-p1 The list of new developments, bug fixes and the required versions of ROOT and Geant4 for each version can be found in the History file.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/vmc/",
	"title": "VMC Core",
	"tags": [],
	"description": "",
	"content": "Chapter 3.2 VMC Core This chapter presents the core VMC package and the new multiple engine functionality.\nVMC Core Multiple VMC Engines "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/vmc/vmc-core/",
	"title": "VMC Core",
	"tags": [],
	"description": "",
	"content": "The core of the VMC, vmc, provides a set of interfaces which completely decouple the dependencies between the user code and the concrete Monte Carlo:\nTVirtualMC: Interface to the concrete Monte Carlo program TVirtualMCApplication: Interface to the user\u0026rsquo;s Monte Carlo application TVirtualMCStack: Interface to the particle stack TVirtualMCDecayer: Interface to the external decayer TVirtualMCSensitiveDetector: Interface to the user\u0026rsquo;s sensitive detector The implementation of the TVirtualMC interface is provided for two Monte Carlo transport codes, GEANT3 and Geant4, with the VMC packages listed below. The implementation for the third Monte Carlo transport code, FLUKA, has been discontinued by the FLUKA team in 2010.\nThe other three interfaces are implemented in the user application. The user has to implement two mandatory classes: the MC application (derived from TVirtualMCApplication) and the MC stack (derived from TVirtualMCStack), optionally an external decayer (derived from TVirtualMCDecayer) can be introduced. The user VMC application is independent from concrete transport codes (GEANT3, Geant4, FLUKA). The transport code which will be used for simulation is selected at run time - when processing a ROOT macro where the concrete Monte Carlo is instantiated.\nThe relationships between the interfaces and their implementations are illustrated in the class diagrams: User MC application , Virtual MC , demonstarting the decoupling between the user code and the concrete transport code.\nMultiple VMCs Since the development version the simulation can be shared among multiple different engines deriving from TVirtualMC which are handled by a singleton TMCManager object.\nSee more detailed description in the dedicated section.\nRoot IO Manager Root IO manager class, TMCRootManager, facilitates use of ROOT IO in VMC examples and it also handles necessary locking in multi-threaded applications.\nIt was first provided in Geant4 VMC in the MTRoot sub-package and moved to the VMC core (since vmc 2.0 and geant4_vmc 6.0).\n"
},
{
	"uri": "https://ihrivnac.github.io/download/git-geant3/",
	"title": "Geant3",
	"tags": [],
	"description": "",
	"content": "Development version (the whole repository):\ngit clone http://github.com/vmc-project/geant3.git To switch to the \u0026lsquo;pro\u0026rsquo; tagged version 4.1 (compatible with vmc 2.x, ROOT 6.x):\ncd geant3 git checkout v4-1 To switch to the \u0026lsquo;old\u0026rsquo; tagged version 3.9.p1 (compatible with vmc 1,x, ROOT 6.x):\ncd geant3 git checkout v3-9-p1 To switch to the \u0026lsquo;old\u0026rsquo; tagged version 2.7.p2 (compatible with ROOT 5.x):\ncd geant3 git checkout v2-7-p2 For older versions see the correspondent tag and the required version of ROOT in the history file.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/",
	"title": "Geant4 VMC",
	"tags": [],
	"description": "",
	"content": "Chapter 3.3 Geant4 VMC Geant4 VMC represents the realisation of the Virtual Monte Carlo (VMC) for Geant4. It can be also seen as a Geant4 application implemented via the VMC interfaces. It implements all Geant4 user mandatory classes and user action classes, which provide the default Geant4 VMC behaviour, that can be then customized by a user in many ways.\nGeometry Definition \u0026amp; Navigation Magnetic Field Sensitive Detectors and Volumes Physics Lists Stacking of Particles Special Cuts and Regions User Geant4 Classes Visualization Switching User Interfaces Multi-threaded Processing Verbosity Verbosity for Developers Source code documentation "
},
{
	"uri": "https://ihrivnac.github.io/installation/geant4_vmc/",
	"title": "Installing Geant4 VMC",
	"tags": [],
	"description": "",
	"content": "Geant4 VMC requires the VMC core package, ROOT and Geant4 installed, and optionally, it can be built with VGM. See below tips for configuration and installation of these packages.\nThe vmc core package was separated from the ROOT source into a new stand-alone vmc package in the GitHub vmc-project organization. The motivation for this step was a gain in flexibility and faster workflow for new developments of multiple engine mode. The vmc package in ROOT is deprecated since ROOT version 6.18 (its compilation is optional) and it is going to be removed in the next ROOT version, 6.26. The VMC stand-alone is supported since Geant4 VMC 5.0.\nGeant4 VMC uses CMake to configure a build system for compiling and installing the headers, libraries and CMake configuration files. To install geant4_vmc:\nFirst get the Geant4 VMC source from the Download page. We will assume that the Geant4 VMC package sits in a subdirectory /mypath/geant4_vmc Create build directory alongside our source directory $ cd /mypath $ mkdir geant4_vmc_build $ ls geant4_vmc geant4_vmc_build To configure the build, change into the build directory and run CMake: $ cd /mypath/geant4_vmc_build $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/geant4_vmc_install /mypath/geant4_vmc If ROOT and Geant4 environment was defined using thisroot.[c]sh and geant4.[c]sh scripts, there is no need to provide path to their installations. Otherwise, they can be provided using -DROOT_DIR and -DGeant4_DIR cmake options.\nSince Geant4 VMC 5.4, the VMC stand-alone library has to be provided using -DVMC_DIR cmake option. If the VMC stand-alone library is not found, the deprecated VMC library in ROOT (availble if ROOT was built with the vmc option enabled) can still be used, a deprecation warning will be issued in this case.\nSince Geant4 VMC 6.0, the deprecated VMC library in ROOT cannot be used and building against ROOT built with the vmc option enabled will fail with CMake error.\nAfter the configuration has run, CMake will have generated Unix Makefiles for building Geant4 VMC. To run the build, simply execute make in the build directory: $ make -jN where N is the number of parallel jobs you require (e.g. if your machine has a dual core processor, you could set N to 2).\nIf you need more output to help resolve issues or simply for information, run make as $ make -jN VERBOSE=1 Once the build has completed, you can install Geant4 VMC to the directory you specified earlier in CMAKE_INSTALL_PREFIX by running $ make install This will build geant4_vmc, g4root and examples packages. For VMC examples see VMC examples installation page.\nBuild Options Required and Optional Packages The instructions above apply to the installation since the version 3.0 built against Geant4 10.00.p03. For the installation of the previous versions see\nOlder Versions Special Installation "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/vmc/multiple-vmc/",
	"title": "Multiple VMC Engines",
	"tags": [],
	"description": "",
	"content": "Introduction The VMC package allows splitting the event simulation among multiple engines. The criteria of how to split the simulation have to be defined by the user and among others the decision which engine to be used could depend on\ngeometry particle phase space particle type any combination of that \u0026hellip; Running multiple engines is fully supported for\nGEANT3_VMC GEANT4_VMC This also allows the user to implement his/her own class deriving from TVirtualMC to be used in a split simulation. The communication between the engines is handled by a singleton object of type TMCManager such that the user does not have to deal with special implementation details. Hence, pausing an engine, re-starting it or transferring tracks between them is done automatically and at the same time the user stack is kept up-to-date. Furthermore, the same user application derived from TVirtualMCApplication together with the same user stack derived from TVirtualMCStack can be used for both a single engine run or a simulation split among multiple ones.\nHow multiple engines are handled To keep the overhead as small as possible, the TMCManager object has to be requested by the user explicitly during construction of the user application by calling TVirtualMCApplication::RequestManager(). That makes the manager available via the protected member TVirtualMCApplication::fMCManager and a pointer can also always be obtained via TMCManager::Instance(). In a single run, on the other hand, there is no such object and the VMC would directly interacts with the user\u0026rsquo;s particle stack. In that case the scenario of how that VMC is treated and interacts with other objects is the same as it was in previous versions of the VMC package.\nThe most important interfaces of the TMCManager to deal with multiple VMCs are:\nvoid SetUserStack(TVirtualMCStack* userStack)\nThis notifies the manager about the user stack such that it will be kept up-to-date during the simulation. Not setting it makes the TMCManager abort the execution. void ForwardTrack(Int_t toBeDone, Int_t trackId, Int_t parentId, TParticle* userParticle)\nThe user is always the owner of all track objects (aka TParticle) being created. Hence, all engine calls to TVirtualMCStack::PushTrack(...) are first redirected to the user stack where a TParticle has to be created on the heap. After that, this method has to be invoked to forward the pointer of the created TParticle object. If a particle should be pushed to an engine other than the one currently running, the engine\u0026rsquo;s ID has to be provided as the last argument. void TransferTrack(Int_t targetEngineId)\nFor instance during TVirtualMCApplication::Stepping() the user might decide that the current track should be transferred to another engine, e.g., if a certain volume is entered. By specifying the ID or the pointer to the target engine the manager will take care of interrupting the track in the current engine, extracting the kinematics and geometry state and it will save these information for the target engine. template \u0026lt;typename F\u0026gt; void Apply(F f)\nThis assumes f to implement the () operator and taking a TVirtualMC pointer as an argument. f will be then called for all engines. template \u0026lt;typename F\u0026gt; void Init(F f)\nThis works as TMCManager::Apply during the initialization of the engines. It can also be called without an argument such that no additional user routine is included. void Run(Int_t nEvents)\nA run involving all registered VMCs is steered for the specific number of events. void ConnectEnginePointers(TVirtualMC *\u0026amp;mc)\nThis gives the possibility for a user to pass a pointer variable which will always be set to point to the currently running engine. Note, however, that there is a protected member TVirtualMCApplication::fMC which always points to the currently running engine and it can therefore be used within the application\u0026rsquo;s code. TVirtualMC *GetCurrentEngine()\nThis provides the user with a pointer to the currently running engine. An example of how the TMCManager is utilized in a multi-run can be found in E03c example of the geant4_vmc repository. The diff of e.g E03/E03a and E03/E03c nicely highlights the small amount of extensions necessary to use the same application and stack for both a single and a multi-run.\nImplementation and workflow example The general workflow of a multi-run is explained using some of the classes/implementations of the E03c example mentioned above.\nImplementation\nImplement your application and stack as you have done before. Request the TMCManager in your constructor by calling TVirtualMCApplication::RequestMCManager() Ex03MCApplication::Ex03MCApplication(const char* name, const char* title, Bool_t isMulti, Bool_t splitSimulation) { // some construction // user stack fStack = new Ex03MCStack(1000); if(isMulti) { RequestManager(); fMCManager-\u0026gt;SetUserStack(fStack); } // further construction } At an appropriate stage (i.e. in UserStack::PushTrack(...)) you would call TMCManager::ForwardTrack(...) to forward the pointer to your newly constructed TParticle object. void Ex03MCStack::PushTrack(Int_t toBeDone, Int_t parent, ..., Int_t\u0026amp; ntr, ...) { // TParticle construction yielding pointer \u0026#34;particle\u0026#34; // User defines the track ID ntr = GetNtrack() - 1; // Forward to the TMCManager in case of multi-run if(auto mgr = TMCManager::Instance()) { mgr-\u0026gt;ForwardTrack(toBeDone, ntr, parent, particle); } // further implementations } Whenever needed, check the presence of TMCManager to decide whether the code should work for single or multi-run, e.g. in the constructor of Ex03DetectorConstruction where its member fMC is setup to point to the currently running VMC in the multi-run scenario. Ex03DetecorConstruction::Ex03DetectorConstruction(...) { // some construction if(auto mgr = TMCManager::Instance()) { mgr-\u0026gt;ConnectEnginePointer(fMC); // ... } // maybe some more construction } Transfer a track involving TMCManager::TransferTrack(...). If the target VMC ID coincides with the one currently running, nothing will happen and the simulation would just continue. Ex03MCApplication::Stepping() { // some implementation Int_t targetId = -1; if (fMC-\u0026gt;GetId() == 0 \u0026amp;\u0026amp; strcmp(fMC-\u0026gt;GetCurrentVolName(), \u0026#34;ABSO\u0026#34;) == 0) { targetId = 1; } else if (fMC-\u0026gt;GetId() == 1 \u0026amp;\u0026amp; strcmp(fMC-\u0026gt;GetCurrentVolName(), \u0026#34;GAPX\u0026#34;) == 0) { targetId = 0; } if (targetId \u0026gt; -1) { if (fVerbose.GetLevel() \u0026gt; 2) { Info(\u0026#34;Stepping\u0026#34;, \u0026#34;Transfer track\u0026#34;); } fMCManager-\u0026gt;TransferTrack(targetId); } // further implementations } To use the same stack in both scenarios (single and multi-run), one can always check whether the manager is present by checking if TMCManager::Instance() returns a valid pointer value. Usage\nInstantiate your application (here the user stack is created during construction of the application, see above) auto isMulti = true; auto splitSimulation = true; auto appl = new Ex03MCapplication(\u0026#34;multiApplication\u0026#34;, \u0026#34;multiApplication\u0026#34;, isMulti, splitSimulation); Instantiate the engines you want to use (these are registered automatically to the manager). In the E03c example this is done in TVirtualMCApplication::InitMC but to clarify, it is written here explicitely, auto engine1 = new TGeant3(...); auto engine2 = new TGeant4(...); // Nothing further to be done Call TMCManager::Init(...) (if needed with your custom initialization procedure, see above; that can of course also be wrapped into another method of your application as it is done here), void Ex03MCApplication::InitMC(std::initializer_list\u0026lt;const char*\u0026gt; setupMacros) { // some implementation fMCManager-\u0026gt;Init([this](TVirtualMC* mc) { mc-\u0026gt;SetRootGeometry(); mc-\u0026gt;SetMagField(fMagField); mc-\u0026gt;Init(); mc-\u0026gt;BuildPhysics(); }); // further implementations } The lambda argument will be called for each registered VMC separately. If necessary, it can be more specific. Instead of passing a lambda function, a function pointer could be given or also an object. The only requirement is that what is passed implements a () operator taking a VMC pointer as an argument. Call TMCManager::Run(...) specifying the desired number of events to be simulated. void Ex03MCApplication::RunMC(Int_t nofEvents) { // some implementation fMCManager-\u0026gt;Run(nofEvents); // further implementations } Important comments\nThe geometry is built once centrally via the TMCManager calling\nTVirtualMCApplication::ConstructGeometry(), TVirtualMCApplication::MisalignGeometry(), TVirtualMCApplication::ConstructOpGeometry() and therefore, it is expected that these methods do not depend on any engine.\nIf multiple engines have been instantiated, never call TVirtualMC::ProcessRun(...) or other steering methods on the individual engine because that would bypass the TMCManager and will lead to inconsistent behavior.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/sensitive-volumes/",
	"title": "Sensitive Detectors and Volumes",
	"tags": [],
	"description": "",
	"content": "Sensitive Detectors Recently (since ROOT version v6.13.04) a new interface to user sensitive detector, TVirtualMCSensitiveDetector, has been added in the set of VMC interfaces. The support for this new way of definig sensitive detector is available since geant3 2.6 and geant4_vmc 4.0.\nThe user sensitive detectors object should be associated to the selected volumes in the new dedicated MCApplication function: void TVirtualMCApplication::SetSensitiveDetectors()\nusing the new TVirtualMC function: void TVirtualMC::SetSensitiveDetector( const TString\u0026amp; volumeName, TVirtualMCSensitiveDetector* userSD); Users can also choose whether scoring should be performed exclusively via sensitive detectors or via both sensitive detectors and MCApplication::Stepping() using the function void VirtualMC::SetExclusiveSDScoring(Bool_t); If exclusive scoring is selected, the MCApplication::Stepping() is not called by MC.\nTo demonstrate the usage of this new interfaces the E03 example was split in two variants:\nE03a - scoring via sensitive volumes and MCApplication::Stepping (old way) E03b - scoring via sensitive detectors derived from new TVirtualMCSensitiveDetector interface Sensitive Volumes The VMC interfaces did not provide functions for a user selection of sensitive volumes and (unless the new sensitive detector framework is used) the user MCApplication::Stepping() is called in all volumes. In order to speed up simulation, in Geant4 VMC (since version 2.13) the user has a possibility to select sensitive volumes. If any selection is provided, the user MCApplication::Stepping() is called only from the selected sensitive volumes.\nThe selection of sensitive volumes can be done in two ways:\nVia the following Geant4 VMC command:\n/mcDet/addSDSelection volName1 [volName2 ...] The command can be applied more times, the new selection is each time added to the existing ones.\nVia labeling volumes directly in TGeo geometry. In this case, user has to notify Geant4 VMC about using the sensitive volumes selection from TGeo by applying Geant4 VMC command:\n/mcDet/setSDSelectionFromTGeo true The volumes in TGeo geometry are set sensitive by setting the option \u0026ldquo;SV\u0026rdquo; to TGeoVolume objects: TGeoVolume* myVolume = ...; myVolume-\u0026gt;SetOption(\u0026#34;SV\u0026#34;); User can also choose a different string than \u0026ldquo;SV\u0026rdquo; for sensitive volumes labeling. In this case, they have to notify Geant4 VMC about the label via the Geant4 VMC command:\n/mcDet/setSVLabel MyLabel Note that the option set via TGeoVolume::SetOption function is not persistent.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/",
	"title": "User Guide",
	"tags": [],
	"description": "",
	"content": "Chapter 3 User Guide Introduction VMC Concept VMC Project VMC Core VMC Core Multiple VMC Engines Geant4 VMC Geometry Definition \u0026amp; Navigation Magnetic Field Sensitive Detectors and Volumes Physics Lists Stacking of Particles Special Cuts and Regions User Geant4 Classes Visualization Switching User Interfaces Multi-threaded Processing Verbosity Verbosity for Developers Source code documentation Geant3 \u0026#43; VMC Geant3 \u0026#43; VMC Content G4Root "
},
{
	"uri": "https://ihrivnac.github.io/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Examples This chapter presents the examples of usage of VMC.\nVMC Examples Experiment Frameworks "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant3+vmc/",
	"title": "Geant3 + VMC",
	"tags": [],
	"description": "",
	"content": "Chapter 3.4 Geant3 + VMC The geant3 package provided in vmc-project contains both the Geant3.21 code itself and the implementation of the TVirtualMC interface, TGeant3.\nGeant3 \u0026#43; VMC Content "
},
{
	"uri": "https://ihrivnac.github.io/download/git-geant4_vmc/",
	"title": "Geant4 VMC",
	"tags": [],
	"description": "",
	"content": "Development version (the whole repository):\ngit clone http://github.com/vmc-project/geant4_vmc.git To switch to the \u0026lsquo;pro\u0026rsquo; tagged version 6.2 (compatible with vmc 2.x, Geant4 11.1.x):\ncd geant4_vmc git checkout v6-2 To switch to the \u0026lsquo;old\u0026rsquo; tagged version 6.1.p2 (compatible with vmc 2.x, Geant4 11.0.x):\ncd geant4_vmc git checkout v6-1-p2 The list of new developments, bug fixes and the required versions of ROOT and Geant4 for each version can be found in the history file.\nDownload Geant4 - from the Geant4 Web site\n"
},
{
	"uri": "https://ihrivnac.github.io/installation/examples/",
	"title": "Installing and Running Examples",
	"tags": [],
	"description": "",
	"content": "The following instructions apply to the installation since the version 3.00. Since this 3.00, VMC examples are installed with CMake.\nThe VMC examples libraries require ROOT installation and the VMC core package if using ROOT built without vmc enabled. The VMC examples programs can be built against Geant3 with VMC or Geant4 VMC libraries. Only the examples with the multiple engine mode (at present only E03c) can be built with both Geant3 and Geant4 VMC libraries. The VMC_WITH_Multi CMake option has to be set, too, in this special case.\nBy default, the VMC examples libraries and the VMC examples programs are built against Geant4 VMC libraries together with Geant4 VMC installation. Below we provide the instructions how to build VMC examples altogether outside Geant4 VMC. The analogous instructions can be used to build each example individually or to build a user application.\nTo install all examples\nFirst get the Geant4 VMC source from the Download page, as the examples are provided within this package. We will assume that the Geant4 VMC package sits in a subdirectory /mypath/geant4_vmc\nCreate build directory alongside our source directory for installation with Geant4: $ cd /mypath $ mkdir examples_build_g4 $ ls geant4_vmc examples_build_g4 and/or for installation with Geant3: $ cd /mypath $ mkdir examples_build_g3 $ ls geant4_vmc examples_build_g3 and/or for the installation without specific MC (only libraries will be installed in this case): $ cd /mypath $ mkdir examples_build $ ls geant4_vmc examples_build To configure the build, change into the build directory and run CMake with either -DVMC_WITH_Geant4 $ cd /mypath/example_build_g4 $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/examples_install_g4 \\ -DVMC_WITH_Geant4=ON \\ -DGeant4VMC_DIR=/mypath/geant4_vmc_install/lib[64]/Geant4VMC-3.0.0 \\ /mypath/geant4_vmc/examples or -DVMC_WITH_Geant3, $ cd /mypath/example_build_g3 $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/examples_install_g3 \\ -DVMC_WITH_Geant3=ON \\ -DGeant3_DIR=/mypath/geant3_install/lib[64]/Geant3-2.0.0 \\ -DPythia6_LIB_DIR=/my_path_to_pythia6_library \\ /mypath/geant4_vmc/examples or with VMC_WITH_Multi, $ cd /mypath/example_build_multi $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/examples_install_multi \\ -DVMC_WITH_Geant3=ON \\ -DVMC_WITH_Geant4=ON \\ -DVMC_WITH_Multi=ON \\ -DGeant3_DIR=/mypath/geant3_install/lib[64]/Geant3-2.0.0 \\ -DGeant4VMC_DIR=/mypath/geant4_vmc_install/lib[64]/Geant4VMC-3.0.0 \\ -DPythia6_LIB_DIR=/my_path_to_pythia6_library \\ /mypath/geant4_vmc/examples or no specific MC: $ cd /mypath/example_build_g3 $ cmake -DCMAKE_INSTALL_PREFIX=/mypath/examples_install \\ -DCMAKE_MODULE_PATH=/mypath/geant4_vmc_install/lib[64]/Geant4VMC-3.0.0/Modules \\ /mypath/geant4_vmc/examples\nNote that in the last case, you still have to define the path to CMake configuration files used in examples which are provided with both Geant4 VMC and Geant3 CMake installations. Only examples libraries are built and installed in this case.\nIf ROOT and Geant4 environment was defined using thisroot.[c]sh and geant4.[c]sh scripts, there is no need to provide the path to their installations. Otherwise, they can be provided using -DROOT_DIR and -DGeant4_DIR cmake options.\nSince ROOT 6.18, building the VMC library is optional. When using ROOT built with the vmc option enabled, then Geant4 VMC will automatically use the VMC library from ROOT, otherwise the VMC stand-alone library has to be provided using -DVMC_DIR cmake option. After the configuration has run, CMake will have generated Unix Makefiles for building examples. To run the build, simply execute make in the build directory: $ make -jN where N is the number of parallel jobs you require (e.g. if your machine has a dual core processor, you could set N to 2). If you need more output to help resolve issues or simply for information, run make as $ make -jN VERBOSE=1 Once the build has completed, you can install examples to the directory you specified earlier in CMAKE_INSTALL_PREFIX by running $ make install This will install examples libraries in lib[64] and executables in bin directory in CMAKE_INSTALL_PREFIX directory.\nBuild Options Running examples For the old instructions see:\nOlder Versions "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/physics-lists/",
	"title": "Physics Lists",
	"tags": [],
	"description": "",
	"content": "Physics list selection Physics Geant4 VMC does not provide a default physics list. User have to choose the physics list from the physics lists provided in Geant4 (see the Geant4 Physics List Guide or include their own physics list. The choice of the physics list is done via the option specified with creating TG4RunConfiguration object. This option is passed asthe second argument in TG4RunConfiguration constructor (see examples for more details).\nThis option can be defined as:\n\u0026#34;\u0026lt;g4-physics-list\u0026gt;[_\u0026lt;EM-option\u0026gt;][+extra][+optical][+radDecay]\u0026#34; where\n\u0026lt;g4-physics-list\u0026gt; - is a name of a Geant4 physics list; eg. FTFP_BERT, QGSP, \u0026hellip; It is also possible to select \u0026ldquo;emStandard\u0026rdquo; which builds only G4EmStandardPhysics() and G4DecayPhysics() _\u0026lt;EM-option\u0026gt; - is the EM physics option (none, _EMV, _EMX, _EMY, _LIV, _PEN) +extra - adds G4ExtraPhysics +optical - adds G4OpticalPhysics +radDecay - adds G4RadioactiveDecayPhysics Examples:\n\u0026#34;FTFP_BERT_EMV+optical\u0026#34; \u0026#34;QGSP_BIC_EMY+radDecay\u0026#34; The \u0026lt;g4-physics-list\u0026gt;_\u0026lt;EM-option\u0026gt; must represent a valid Geant4 physics list (except for \u0026ldquo;emStandard\u0026rdquo;). Since Geant4 9.5 it is possible to combine all EM options with all physics lists.\nSpecial processes In order to activate the support of VMC features like the VMC cuts, VMC process controls, user has to activate the special processes defined in TG4SpecialPhysicsList. The selection of special processes is passed as the third argument in TG4RunConfiguration constructor (see examples for more details):\n\u0026#34;[stepLimiter][+specialCuts][+specialControls][+stackPopper]\u0026#34; where\n\u0026quot;stepLimiter\u0026quot; - step limiter (default) \u0026quot;specialCuts\u0026quot; - VMC cuts \u0026quot;specialControls\u0026quot; - VMC controls for activation/inactivation selected processes \u0026quot;stackPopper\u0026quot; - stack popper physics Examples:\n\u0026#34;stepLimit+specialCuts\u0026#34; \u0026#34;stepLimit+specialCuts+stackPopper\u0026#34; Composed physics list According to the user selection, Geant4 VMC creates a TG4ComposedPhysicsList object which is a composition of a selected Geant4 physics list (or a user physics list), the extra physics list ( TG4ExtraPhysicsList - in development version only) and the TG4SpecialPhysicsList object. The inclusion of the extra physics list is optional. The composed physics list processes the Geant4 (or user) physics list in the first order, then adds the extra physics processes (if selected) and finally the special processes, registered in TG4SpecialPhysicsList, are added in the last order.\nSince version 2.13, the user physics selection is added to the TGeant4 object title so that it can be retrievable in a user application.\nInspecting particles and physics processes The instantiated particles and physics processes can be the viewed with the following Geant4 and Geant4 VMC commands.\nTo list all particles and processes:\n/particle/list /process/list /mcPhysics/dumpAllProcess To inspect a selected particle:\n/particle/select particleName /particle/process/dump /particle/property/dump /particle/property/decay/dump To print the mapping of G4 processes to VMC process codes and VMC (G3-like) process controls:\n/mcPhysics/printProcessMCMap /mcPhysics/printProcessControlMap Electromagnetic physics Users can tailor the extra physics processes provided by Geant4 via the commands defined in the /physics_lists/em/ command directory and switch on the muon or gamma nuclear interaction, synchrotron radiation, gamma or positron conversion to muon pair or positron conversion to hadrons processes, which are not which are not included by default:\n/physics_lists/em/SyncRadiation true|false /physics_lists/em/SyncRadiationAll true|false /physics_lists/em/GammaNuclear true|false /physics_lists/em/MuonNuclear true|false /physics_lists/em/GammaToMuons true|false /physics_lists/em/PositronToMuons true|false /physics_lists/em/PositronToHadrons true|false Users can also customize the parameters of the electromagnetic physics processes using the commands in the following directories (use interactive help to get more information):\n/process/eLoss/ /process/msc/ /process/em/ Since Geant4 VMC version 2.10, it is also possible to choose an extra model of energy loss, fluctuations or multiple scattering for selected tracking media and selected particles. This can be done via the following built-in commands:\n/mcPhysics/emModel/setEmModel PAI /mcPhysics/emModel/setRegions trackingMedium1 [trackingMedium2 ...] /mcPhysics/emModel/setParticles all The setRegions and setParticles commands must be followed by the list of tracking media names and particle names respectively, separated with a blank space. The setParticles command can also take as a parameter the keyword \u0026quot;all\u0026quot;. The model will be then applied to all particles.\nAt present, the following models are supported: PAI and PAIPhoton models which are applied to ionisation process, and SpecialUrbanMsc, a special model tuned for ALICE EMCAL detector, which is applied to e- and e+ multiple scattering processes.\nHadronic physics User can activate a generation of the cross sections plots for a given projectile particle and a target element via the following commands:\n/mcCrossSection/makeHistograms [true|false] /mcCrossSection/setParticle proton /mcCrossSection/setElement Al The default energy or momentum limits and the number of bins can be customised via the commands:\n/mcCrossSection/setMinKinE 1 MeV /mcCrossSection/setMaxKinE 1 TeV /mcCrossSection/setMinMomentum 10 MeV /mcCrossSection/setMaxMomentum 10 TeV /mcCrossSection/setNofBinsE 900 /mcCrossSection/setNofBinsP 800 It is also possible to print the cross section value for a selected energy or a momentum for a selected cross section type (or all types) via the following commands:\n/mcCrossSection/setParticle anti_proton /mcCrossSection/setElement H /mcCrossSection/setMomentum 0.3 GeV /mcCrossSection/printCrossSection All How to apply Geant4 commands in a Root user session is explained at the section on Switching User Interfaces.\n"
},
{
	"uri": "https://ihrivnac.github.io/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Reference Documentation This chapter provides the links to the VMC packages reference documentation\nVMC core Geant4 VMC Examples G4Root "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/g4root/",
	"title": "G4Root",
	"tags": [],
	"description": "",
	"content": "Chapter 3.5 G4Root The G4Root package is an interface allowing running a GEANT4 simulation with a ROOT geometry. In fact it is just the G4 navigation that uses directly the TGeo geometry. Though it is distributed in geant4_vmc, it can be built and used independently from VMC.\nSee more details on the G4Root Reference web page.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/stacking-of-particles/",
	"title": "Stacking of Particles",
	"tags": [],
	"description": "",
	"content": "The user VMC stack is used differently in Geant3 VMC and Geant4 VMC. Geant3 VMC pops both primary and secondary particles as they are provided by TVirtualMCStack::PopNextTrack(), while Geant4 VMC pops only primary particles using TVirtualMCStack::PopPrimaryForTracking() from the VMC stack.\nStacking of secondary particles is then handled by Geant4 kernel and the user VMC stack only monitors this stacking. By default, Geant4 VMC saves each secondary particle when it starts its tracking (at the the pre-track phase). User can customize this default behaviour and choose also not to save secondary particles at all or to save them in the step of their parent particle, immediately after their creation. This can be done using the command (see in the section on Switching User Interfaces how to apply Geant4 commands in a Root user session):\n/mcTracking/saveSecondaries selection selection = DoNotSave, SaveInPreTrack, SaveInStep The consequence of this is that, by default, the particles added to the VMC stack in other than TVirtualMCApplication::GeneratePrimaries() functions are ignored in Geant4 tracking. Users have to activate the stack popper special process (see the section on Physics list selection), if they want to add particles to the stack during tracking. The added particles are then handled as secondaries of the current track.\nThe stack classes in the VMC examples provide the same stacking mechanism for both Geant3 and Geant4 MCs and they are recommended to be used in a user application.\n"
},
{
	"uri": "https://ihrivnac.github.io/download/tar-files/",
	"title": "Tar Files",
	"tags": [],
	"description": "",
	"content": "Pro versions Package Version Tar file Tested with vmc 2.0 vmc-2-0.tar.gz ROOT 6.24/06 and 6.26/10 geant3 4.1 geant3-4-1.tar.gz vmc 2.0, ROOT 6.24/06, 6.26/00 and 6.26/10 geant4_vmc 6.2 geant4_vmc-6-2.tar.gz vmc 2.0, ROOT 6.26/10, Geant4 11.1 (with embedded CLHEP 2.4.6.2), VGM 5.1, Garfield 4.0 In general, the VMC packages can be built with the Root version which they were tested with and higher, and Geant4 VMC with the Geant4 version which it was tested with including the patches. Note that the Geant4 patches released after the Geant4 VMC tag do not appear in the table above, it is however recommended to update Geant4 with each patch release.\nOld versions Package Version Tar file Tested with geant3 3.9.p1 v3-9-p1.tar.gz vmc 1.1.p1, ROOT 6.24/06 geant4_vmc 6.1.p2 v6-1-p2.tar.gz vmc 2.0, ROOT 6.26/04, Geant4 11.0.p2 (with embedded CLHEP 2.4.5.1), VGM 5.0, Garfield 4.0 geant3 2.7.p2 v2-7-p2.tar.gz ROOT 5.34/36 "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant3+vmc/geant3+vmc-content/",
	"title": "Geant3 + VMC Content",
	"tags": [],
	"description": "",
	"content": " Only the Geant3.21 code itself and the implementation of the TVirtualMC interface, TGeant3, provided in geant3 are maintained by the VMC project.\nGeant3.21 The updated version of Geant3.21 that includes several bug fixes compared to the standard version in CERNLIB. In this version all Geant3 gxxxxx routines have been renamed g3xxxxx.\nThe old Makefile system was replaced with a CMake based system since version 2.0.\nSee also Geant3.21 User Guide\nTGeant3 (Geant3 VMC) The directory TGeant3 contains the classes TGeant3 and TGeant3TGeo, which implement the TVirtualMC interface.\nExamples The directory examples includes a set of FORTRAN examples. These examples are not maintained and tested in the VMC project test suites. Instead, the geant3 package is tested using the test suites defined in geant4_vmc/examples.\n"
},
{
	"uri": "https://ihrivnac.github.io/publications/",
	"title": "Publications",
	"tags": [],
	"description": "",
	"content": "Chapter 6 Publications This chapter lists the presentations \u0026amp; publication related to VMC.\nPublications List "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/special-cuts-and-regions/",
	"title": "Special Cuts and Regions",
	"tags": [],
	"description": "",
	"content": "The way of applying cuts is different in Geant3 and Geant4. In Geant3, the cuts are defined as a limit in energy, which is applied both as an energy threshold (a secondary particle is not produced if its energy is beyond the threshold) and a tracking cut (a particle is stopped when its energy gets below the cut).\nInn Geant4, there is defined a unique cut in range which is then converted to an energy threshold per particle and material. The advantage is that you keep the same spatial resolution of your energy deposit over the whole detector. It is also possible to define cuts per regions, as in big experimental setups you may want to speed up your simulation by setting a higher cut in the support structures etc. See more details at the Geant4 User Guide for Application Developers, section Production Threshold versus Tracking Cut.\nVMC cuts The VMC provides a possibility for a user to define cuts in Geant3 way. The cuts can be defined globally or per tracking medium via the following TVirtualMC functions: gMC-\u0026gt;SetCut(cutname, cutValue); gMC-\u0026gt;Gstpar(medId, cutName, cutValue);\nThe user defined VMC cuts and their interpretation in Geant4 can be viewed with the following commands:\nTo print the cut values for the given cut type (cutName) and control values for the given control type (controlName) for all tracking media:\n/mcDet/printCuts cutName /mcDet/printControls controlName To print global cuts and global process controls:\n/mcPhysics/printGlobalCuts /mcPhysics/printGlobalControls To print the user limits (including the VMC cuts and controls) set for the specified volume:\n/mcPhysics/printVolumeLimits volName Geant4 cuts By default, Geant4 VMC ignores the VMC cuts and applies only the global cut in range defined in the physics list. The default global cut value in Geant4 VMC is 1*mm for all particles which cut is applied for (gamma, e-, e+). User can change this default value for each particle separately or set a new value for all using the commands:\n/mcPhysics/rangeCutForGamma value /mcPhysics/rangeCutForElectron value /mcPhysics/rangeCutForPositron value /mcPhysics/rangeCuts value Applying VMC cuts in Geant4 In order to take the VMC cuts into account, the user has to activate the special cuts process by switching it on in his g4Config.C (see the section on Physics list selection. This special cuts process applies the VMC cuts as tracking cuts using G4UserLimits.\nWhen the special cuts process is activated, Geant4 VMC defines also regions according to the VMC cuts defined by the user. The regions apply the VMC cuts as an energy threshold. In order to do this, the cut energy has to be converted in range. This conversion is performed in TG4RegionsManager using the Geant4 converter classes G4RToEConvForElectron and G4RToEConvForGamma by iterating within a given range interval up to a given precision. User can change the default precision (2 orders of magnitude) with the command:\n/mcRegions/setRangePrecision value The conversion of VMC cuts to the regions follows these rules:\nIf the VMC energy cut defined by user results in a range cut smaller than the default range cut value defined in user physics list, the VMC cut is ignored and the default range cut is used.\nThe range cut is first evaluated within the range 1e-03mm to 1m; when the range cut order is found, it is refined up to given precision (2 orders of magnitude by default) within 10 values of each order and the range value with the closest energy still smaller than VMC cut is chosen. It may happen that a value cannot be refined up to given precision, then the best found value is returned.\nThe regions are defined only in case when the VMC cuts result in range cuts different from the range cuts in the default region; then the region includes all logical volumes with a given material.\nAs the range cuts do not match precisely to user defined energy cuts, the specialCuts process applies the energy cuts as tracking cuts when a particle with energy cut below threshold is generated.\nUser can select several levels of verbosity to control the process of regions definition:\n/mcVerbose/regionsManager level level = 0 no output 1 number of regions added via VMC 2 the list of all volumes, the cuts in energy and calculated cuts in range 3 all evaluated energy values It is also possible to dump the regions properties for a specified volume or to activate printing properties of all regions:\n/mcRegions/dump volumeName /mcRegions/print true|false How to apply Geant4 commands in a Root user session is explained at the section on Switching User Interfaces.\n"
},
{
	"uri": "https://ihrivnac.github.io/support/",
	"title": "Support",
	"tags": [],
	"description": "",
	"content": "Chapter 7 Support Mailing List Bug Reports "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/user-geant4-classes/",
	"title": "User Geant4 Classes",
	"tags": [],
	"description": "",
	"content": "The default Geant4 VMC behaviour, defined by the Geant4 user mandatory classes and user action classes implemented in Geant4 VMC, can be customized by a user by providing his own class derived from TG4RunConfiguration.\nSuch customization is recommended for including a user own physics list. User has also the possibility to override detector construction and/or primary generation action classes and use an existing Geant4 geometry/primary generator definition with VMC. In other cases, though the customisation is possible and allowed by the design, it has not been tested and so it is not recommended especially for the novice users.\nUser Physics List The example of including user own physics list is provided in the VMC example E03 in Ex03RunConfiguration2 class.\nIn case, a user has registered his own physics list, he has a possibility to combine his own physics list with the TG4SpecialPhysicsList using TG4ComposedPhysics list as it is demonstrated in the VMC example E03, see Ex03RunConfiguration2, and he can then activate any special process as described above.( Another possibility, which requires more expertise, would be to register the special process physics constructor (eg. class TG4SpecialCutsPhysics) in a user own modular physics list.)\nUser Detector Construction Including of user geometry construction is also demonstrated in the example E03 in Ex03RunConfiguration1 class.\nRegions Since version 2.5, users have a possibility to define Geant4 regions by overriding the TG4VUserRegionConstruction class. Definition and including of such a user region construction class in the VMC application is demonstrated in the example E03 in Ex03RunConfiguration3 class.\n"
},
{
	"uri": "https://ihrivnac.github.io/publications/meetings/",
	"title": "Meetings (Old)",
	"tags": [],
	"description": "",
	"content": " "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/visualization/",
	"title": "Visualization",
	"tags": [],
	"description": "",
	"content": "Geant4 visualization and UI drivers can be in Geant4 VMC enabled via dedicated CMake configuration options. See more details in Installing Geant4 VMC.\nThe G3-like functions for visualization defined in TVirtualMC are overcome with the interactive visualization capabilities of both Root and Geant4 geometry modellers, that\u0026rsquo;s why user is encouraged to use these modeller directly. User can set Geant4 visualization options using Geant4 visualization commands, as it is illustrated in the VMC examples in g4vis.in macro.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/switching-user-interfaces/",
	"title": "Switching User Interfaces",
	"tags": [],
	"description": "",
	"content": "The VMC interface provides a common denominator for all implemented MC\u0026rsquo;s and cannot cover all commands available in a Geant4 user session through Geant4 user interface (UI). Switching between the Root UI and the Geant4 UI gives a user the possibility of working with the native Geant4 UI. It is also possible to process a foreign command or a foreign macro in both UIs:\nFrom Root to Geant4 UI Switching UI: root [0] ((TGeant4*)gMC)-\u0026gt;StartGeantUI();\nCall Geant4 macro myMacro.in from Root: root [0] ((TGeant4*)gMC)-\u0026gt;ProcessGeantMacro(\u0026#34;myMacro.in\u0026#34;);\nCall Geant4 command from Root: root [0] ((TGeant4*)gMC)-\u0026gt;ProcessGeantCommand(\u0026#34;/tracking/verbose 1\u0026#34;);\nFrom Geant4 to Root UI Switching UI:\nIdle\u0026gt; /mcControl/root Call Root macro \u0026ldquo;myMacro.C\u0026rdquo; from Geant4:\nIdle\u0026gt; /mcControl/rootMacro myMacro Call Root command from Geant4:\nIdle\u0026gt; /mcControl/rootCmd TBrowser b; Geant4 VMC commands Geant4 VMC implements several Geant4 UI commands associated with the objects defined in Geant4 VMC. To make their Geant4 VMC origin apparent, all these commands start with the prefix mc. Several Geant4 and Geant VMC commands are used in the g4config.in and g4vis.in macros in the VMC examples.\nYou can get an interactive help for all available commands by typing:\nIdle\u0026gt; help or\nIdle\u0026gt; /control/help "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/multi-threaded-processing/",
	"title": "Multi-threaded Processing",
	"tags": [],
	"description": "",
	"content": "Geant4 VMC with Multi-threading Geant4 Since version 3.00, Geant4 VMC supports running Geant4 in multi-threading (MT) mode. The VMC application will run automatically in MT mode when Geant4 VMC is built against Geant4 MT. This default behaviour can be changed via the option specified with creating TG4RunConfiguration passed as the fifth argument in TG4RunConfiguration constructor. (Note that the fourth argument, specialStacking option, cannot be omitted in this case.)\nThe VMC application which has not been migrated to MT should be run in a sequential mode, either with Geant4 VMC built against Geant4 sequential libraries or with Geant4 VMC built against Geant4 MT libraries with disabled multi-threading mode in TG4RunConfiguration. Otherwise its run will stop with an exception.\nAs the VMC classes work as a factory for creating Geant4 application objects (user initialization and user action classes, sensitive detector classes etc.), the main VMC objects: TGeant4 and MCApplication need to be created on both master and worker threads. Creating of all objects on worker threads is triggered from the Geant4 VMC classes. Users need just to implement new functions of TVirtualMCApplication which are then used to clone the application and its containing objects on workers: // required for running in MT virtual TVirtualMCApplication* CloneForWorker() const; // optional virtual void InitForWorker() const; virtual void BeginRunOnWorker(); virtual void FinishRunOnWorker(); virtual void Merge(TVirtualMCApplication* localMCApplication);\nOverriding of TVirtualMCApplication::CloneForWorker() is required, implementation of the other functions is optional.\nThe default number of threads, defined in Geant4, can be changed by setting the environment variable:\nexport G4FORCENUMBEROFTHREADS=4 or\nsetenv G4FORCENUMBEROFTHREADS 4 In applications which do not use G4Root navigation, it can be also changed via Geant4 UI command:\n/run/numberOfThreads 4 Migration of VMC application to Multi-threading Implement the required MCApplication function for MT: virtual TVirtualMCApplication* CloneForWorker() const; and, optionally also the other functions listed in the previous section.\nThe step 1. will also require to implement the constructors for cloning MC application, primary generator, sensitive detectors and eventually other classes instantiated in your application: MyClass(const MyClass\u0026amp; origin); In general, the objects which state is modified during event processing need to be created on workers while the objects which are used in read-only mode can be be shared. See the examples implementation as a guidance.\nReplace your Root manager with TMCRootManager, provided in the vmc library, which implements in a thread-safe way the functions previously provided in the VMC examples in the Ex02RootManager class.\nCarefully check thread-safety of your application code. Note that ROOT has to be initialized for multi-threading via calling TThread::Initialize(); just at start of your Root macro or your application.\nIn VMC examples, this call is executed either in g4libs.C macro or in the example main program.\nImplementation details \u0026amp; tips Dynamic loading of libraries requires to build Geant4 libraries with -ftls-model=global-init compilation flag (which is different from the Geant4 default, -ftls-model=initial-exec) and the tests show that it brings a performance penalty.\nThat\u0026rsquo;s why it is recommended to build the VMC application program linked with all libraries. Since Geant4 VMC 3.00 version, the main functions are provided for all VMC examples together with CMake configuration file for their build.\nBe careful to call TVirtualMCApplication standard constructor when cloning your application: TVirtualMCApplication(origin.GetName(),origin.GetTitle()),\nCheck the existence of TMCRootManager in YourSD::Initialize() as when running in MT mode the TMCRootManager is not instantiated on master but only on workers. if ( TMCRootManager::Instance() ) Register();\nThe vmc package provides a locking mechanism similar to G4AutoLock, which can be used in the user application for handling the operations which are not thread-safe. (It is not demonstrated in the VMC examples, as there is no such use case where locking would be needed.) // An example of use TMCAutoLock in UserClass.cxx // Define mutex in a file scope namespace { // Mutex to lock application when performing not thread-safe operation TMCMutex unsafeOperationMutex = TMCMUTEX_INITIALIZER; } // In a function where unsafeOperation() is called { ... TMCAutoLock lm(\u0026amp;unsafeOperationMutex); unsafeOperation(); lm.unlock(); ... }\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/verbosity/",
	"title": "Verbosity",
	"tags": [],
	"description": "",
	"content": "For many Geant4 VMC classes (like for Geant4 classes) the user can select a higher verbosity level and activate various printings which can help in understanding or debugging his application.\n/mcVerbose/all level Set the same verbose level (level \u0026gt;= 0) to all Geant4 VMC objects. If level = 0 no printing is issued, the higher the level is more printings will be issued. /mcVerbose/geometryManager 2 Activate the debug printing from VGM geometry conversion (when geomRootToGeant4 option is selected) /mcVerbose/regionsManager 1 [2] [3] level=1: print the number of regions added via VMC level=2: print also the list of all volumes, the cuts in energy and calculated cuts in range level=3: print also all evaluated energy values /mcVerbose/composedPhysicsList 2 [3] [4] Set the same verbose level to the registed user physics lists.\nlevel=2: print the table of registered material/cuts couples (the range cuts and energy thresholds per material and particle) level=3: print also info from G4VUserPhysicsList::BuildPhysicsTable for each constructed particle level=4: print also info from G4VRangeToEnergyConverter::Convert() for each material /mcVerbose/specialPhysicsList 1 [4] level=1: print info about constructed special processes level=4: print also info from G4VRangeToEnergyConverter::Convert() for each material /mcVerbose/physicsExtDecayer 1 [2] level=1: print info about the constructed external decayer level=2: print also info about the particles which default decay was disabled by user /mcVerbose/primaryGeneratorAction 2 Print the list of all primary particles for each event. /mcVerbose/runAction 1 Print info at the start and the end of run including the time of the run. /mcVerbose/eventAction 1 [2] [3] level=1: print info at the start of event and the info about number of trajectories in the event if storing trajectories is activated level=2: print also info at the end of event including the time of the event level=3: print also info about the number of primary tracks processed and total number of tracks saved in stack in each event /mcVerbose/trackingAction 2 [3] level=2: print info at the start of each 10th primary track level=3: print also info at the start of each primary track Looping and problematic tracks In order to avoid infinite looping of tracks, Geant4 VMC defines a maximum number of steps allowed (the default value is 30000). User can customize this value by the command:\n/mcTracking/maxNofSteps value When a track reaches the maximum number of steps, Geant4 VMC activates the tracking verbose mode and let the track process a few more steps with printing the verbose info. This can help to identify the positon of the track in the geometry hierarchy. User can change this default behavior and set the desired level of verbosity:\n/mcTracking/loopVerbose level It is also possible to change the verbosity level for a selected track number using the commands:\n/mcTracking/newVerboseTrack trackID /mcTracking/newVerbose level How to apply Geant4 commands in a Root user session is explained at the section on Switching User Interfaces.\n"
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/vebosity-for-developers/",
	"title": "Verbosity for Developers",
	"tags": [],
	"description": "",
	"content": "For many Geant4 VMC classes (like for Geant4 classes) the user can select a higher verbosity level and activate various printings which can help in understanding or debugging his application. Here we list the commands useful rather for Geant4 VMC developers, for the commands useful for users see Verbosity.\n/mcVerbose/SDConstruction 2 Print the volumes IDs (implemented via G4VSensitiveDetector objects) and the maps between volumes and volume IDs. /mcVerbose/runManager 3 Print the logical volume store. /mcVerbose/trackManager 2 Print particleID info from SetTrackInformation. /mcVerbose/physicsManager 2 Print the parameter name and value from calls to Gstpar. /mcVerbose/particlesManager 2 Print the map between the names of special particles in Root and Geant4 (like geantino, opticalphoton, etc.); print also info about particles and ions defined by user. /mcVerbose/physicsProcessControlMap 1 /mcVerbose/physicsProcessMCMap 1 /mcVerbose/physicsStepLimiter 1 /mcVerbose/physicsUserParticles 1 Print info about each constructed special process; in case of map processes (physicsProcessControlMap, physicsProcessMCMap) print also whether the mapping was successful (all physics processes in the user physics list were identified in the maps). "
},
{
	"uri": "https://ihrivnac.github.io/user-guide/geant4_vmc/source-code-documentation/",
	"title": "Source code documentation",
	"tags": [],
	"description": "",
	"content": "Source code documentation has been generated from the source code by Doxygen.\n"
},
{
	"uri": "https://ihrivnac.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ihrivnac.github.io/copyright/",
	"title": "Copyright",
	"tags": [],
	"description": "",
	"content": "Copyright (C) 2019 CERN and copyright holders of VMC Project. This software is distributed under the terms of the GNU General Public License v3 (GPL Version 3), copied verbatim in the file \u0026ldquo;LICENSE\u0026rdquo;.\nCopyright holders Institutions:\nEuropean Organization for Nuclear Research (CERN), Geneva, Switzerland Institut de Physique Nucléaire dʼOrsay (IPNO), Université Paris-Sud, CNRS-IN2P3, Orsay, France Ruprecht Karls Universitaet Heidelberg (DE)* "
},
{
	"uri": "https://ihrivnac.github.io/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "The concept of Virtual MonteCarlo has been developed by the ALICE Software Project . Authors: R.Brun1, F.Carminati*1, I.Hrivnacova2, A.Morsch1*\nThe integration with TGeo, G4Root: A. Gheata*1*\nThe multiple VMC engines: B. Volkel*1,3*\n1 European Organization for Nuclear Research (CERN), Geneva, Switzerland 2 Institut de Physique Nucléaire dʼOrsay (IPNO), Université Paris-Sud, CNRS-IN2P3, Orsay, France 3 Ruprecht Karls Universitaet Heidelberg (DE)\n"
},
{
	"uri": "https://ihrivnac.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ihrivnac.github.io/",
	"title": "VMC Project",
	"tags": [],
	"description": "",
	"content": "VMC Project Virtual Monte Carlo (VMC) defines an abstract layer between a detector simulation user code (MC application) and the Monte Carlo transport code (MC). In this way the user code is independent of any specific MC and can be used with different transport codes within the same simulation application.\nThe implementation of the interface is provided for two Monte Carlo transport codes, GEANT3 and Geant4. The implementation for the third Monte Carlo transport code, FLUKA, has been discontinued by the FLUKA team in 2010.\nVMC was developed by the ALICE Software Project and, after the complete removal of all dependencies from the experiment specific framework, it was included in ROOT and then gradually separated from ROOT into a stand-alone vmc-projet.\nThese new documentation pages were migrated from the ROOT documentation. If you have suggestions about how to improve this documentation, you can let us know. See Support.\nReference paper\nHřivnáčová I et al: The Virtual MonteCarlo,\nECONF C0303241:THJT006,2003; e-Print: cs.SE/0306005\nContact: root-vmc@cern.ch\nLast update: 18/01/2023\n"
}]